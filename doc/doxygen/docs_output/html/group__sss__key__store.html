<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Secure Authenticator APIs References: Sss_key_store</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Secure Authenticator APIs References
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Sss_key_store</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae127477ad33bfef2ba6798bad18b875d" id="r_gae127477ad33bfef2ba6798bad18b875d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#gae127477ad33bfef2ba6798bad18b875d">sss_key_store_context_init</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore, <a class="el" href="structsss__session__t.html">sss_session_t</a> *session)</td></tr>
<tr class="memdesc:gae127477ad33bfef2ba6798bad18b875d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the key store context data structure.  <br /></td></tr>
<tr class="separator:gae127477ad33bfef2ba6798bad18b875d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1457a726e4056e34fe7acf548aa722e7" id="r_ga1457a726e4056e34fe7acf548aa722e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga1457a726e4056e34fe7acf548aa722e7">sss_key_store_allocate</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore, uint32_t keyStoreId)</td></tr>
<tr class="memdesc:ga1457a726e4056e34fe7acf548aa722e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get handle to key store. If the key store already exists, nothing is allocated. If the key store does not exists, new empty key store is created and initialized. Key store context structure is updated with actual information.  <br /></td></tr>
<tr class="separator:ga1457a726e4056e34fe7acf548aa722e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42db9c26617071ae76f5768a668246ad" id="r_ga42db9c26617071ae76f5768a668246ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga42db9c26617071ae76f5768a668246ad">sss_key_store_set_key</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore, <a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject, const uint8_t *data, size_t dataLen, size_t keyBitLen, void *options, size_t optionsLen)</td></tr>
<tr class="memdesc:ga42db9c26617071ae76f5768a668246ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function moves data[] from memory to the destination key store.  <br /></td></tr>
<tr class="separator:ga42db9c26617071ae76f5768a668246ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae84f7cc55e367f1a82263a395bd523" id="r_ga6ae84f7cc55e367f1a82263a395bd523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga6ae84f7cc55e367f1a82263a395bd523">sss_key_store_generate_key</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore, <a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject, size_t keyBitLen, void *options)</td></tr>
<tr class="memdesc:ga6ae84f7cc55e367f1a82263a395bd523"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates key[] in the destination key store.  <br /></td></tr>
<tr class="separator:ga6ae84f7cc55e367f1a82263a395bd523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca415b9e03331912935045923310d4f" id="r_ga9ca415b9e03331912935045923310d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga9ca415b9e03331912935045923310d4f">sss_key_store_get_key</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore, <a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject, uint8_t *data, size_t *dataLen, size_t *pKeyBitLen)</td></tr>
<tr class="memdesc:ga9ca415b9e03331912935045923310d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports plain key[] from key store. As Secure Authenticator doesn't support reading key value, this function returned the ECC public key value stored in keyObject. These public key comes from generating ECC keypair or ECDH with ephemeral key operation.  <br /></td></tr>
<tr class="separator:ga9ca415b9e03331912935045923310d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7414a21953a854954c89e547ce21761c" id="r_ga7414a21953a854954c89e547ce21761c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga7414a21953a854954c89e547ce21761c">sss_key_store_erase_key</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore, <a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject)</td></tr>
<tr class="memdesc:ga7414a21953a854954c89e547ce21761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete / destroy allocated keyObect .  <br /></td></tr>
<tr class="separator:ga7414a21953a854954c89e547ce21761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ce557c06d6cd014ad63ba1c28b9b8d" id="r_ga03ce557c06d6cd014ad63ba1c28b9b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga03ce557c06d6cd014ad63ba1c28b9b8d">sss_key_store_context_free</a> (<a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore)</td></tr>
<tr class="memdesc:ga03ce557c06d6cd014ad63ba1c28b9b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the key store context.  <br /></td></tr>
<tr class="separator:ga03ce557c06d6cd014ad63ba1c28b9b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cf2aea4e78dc0b3e2469eae1d133b2" id="r_ga26cf2aea4e78dc0b3e2469eae1d133b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga26cf2aea4e78dc0b3e2469eae1d133b2">sss_key_object_init</a> (<a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject, <a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *keyStore)</td></tr>
<tr class="memdesc:ga26cf2aea4e78dc0b3e2469eae1d133b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a key object data structure The function initializes keyObject data structure and associates it with a key store in which the plain key and other attributes are stored.  <br /></td></tr>
<tr class="separator:ga26cf2aea4e78dc0b3e2469eae1d133b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e429a389d60abe4b8cac4e244faecbb" id="r_ga4e429a389d60abe4b8cac4e244faecbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga4e429a389d60abe4b8cac4e244faecbb">sss_key_object_allocate_handle</a> (<a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject, uint32_t keyId, <a class="el" href="fsl__sss__api_8h.html#a65bccd97bad72428686bf6aa6ea6f691">sss_key_part_t</a> keyPart, <a class="el" href="fsl__sss__api_8h.html#ae0d9e4fbd1bf4116b5797c4360818c78">sss_cipher_type_t</a> cipherType, size_t keyByteLenMax, uint32_t options)</td></tr>
<tr class="memdesc:ga4e429a389d60abe4b8cac4e244faecbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate / pre-provision memory for new key.  <br /></td></tr>
<tr class="separator:ga4e429a389d60abe4b8cac4e244faecbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d254bc9f3ee97321070240ef8261fc" id="r_gaa7d254bc9f3ee97321070240ef8261fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#gaa7d254bc9f3ee97321070240ef8261fc">sss_key_object_get_handle</a> (<a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject, <a class="el" href="fsl__sss__api_8h.html#ae0d9e4fbd1bf4116b5797c4360818c78">sss_cipher_type_t</a> cipherType, uint32_t keyId)</td></tr>
<tr class="memdesc:gaa7d254bc9f3ee97321070240ef8261fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get handle to an existing allocated/provisioned/created Object.  <br /></td></tr>
<tr class="separator:gaa7d254bc9f3ee97321070240ef8261fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e10bf4b2a4a0d549ab67ab453991cc" id="r_ga59e10bf4b2a4a0d549ab67ab453991cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sss__key__store.html#ga59e10bf4b2a4a0d549ab67ab453991cc">sss_key_object_free</a> (<a class="el" href="structsss__object__t.html">sss_object_t</a> *keyObject)</td></tr>
<tr class="memdesc:ga59e10bf4b2a4a0d549ab67ab453991cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the key object. The function frees key object context.  <br /></td></tr>
<tr class="separator:ga59e10bf4b2a4a0d549ab67ab453991cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae127477ad33bfef2ba6798bad18b875d" name="gae127477ad33bfef2ba6798bad18b875d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae127477ad33bfef2ba6798bad18b875d">&#9670;&#160;</a></span>sss_key_store_context_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_store_context_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsss__session__t.html">sss_session_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for the key store context data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keyStore</td><td>Pointer to key store context. Key store context is updated on function return. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga1457a726e4056e34fe7acf548aa722e7" name="ga1457a726e4056e34fe7acf548aa722e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1457a726e4056e34fe7acf548aa722e7">&#9670;&#160;</a></span>sss_key_store_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_store_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>keyStoreId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get handle to key store. If the key store already exists, nothing is allocated. If the key store does not exists, new empty key store is created and initialized. Key store context structure is updated with actual information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keyStore</td><td>Pointer to key store context. Key store context is updated on function return. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStoreId</td><td>Implementation specific ID, can be used in case security subsystem manages multiple different key stores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga42db9c26617071ae76f5768a668246ad" name="ga42db9c26617071ae76f5768a668246ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42db9c26617071ae76f5768a668246ad">&#9670;&#160;</a></span>sss_key_store_set_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_store_set_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyBitLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>optionsLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function moves data[] from memory to the destination key store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStore</td><td>Key store context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyObject</td><td>Reference to a key and it's properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be stored in Key. When setting ecc private key only, do not include key header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLen</td><td>Length of the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBitLen</td><td>Crypto algorithm key bit length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Pointer to implementation specific options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionsLen</td><td>Length of the options in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga6ae84f7cc55e367f1a82263a395bd523" name="ga6ae84f7cc55e367f1a82263a395bd523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae84f7cc55e367f1a82263a395bd523">&#9670;&#160;</a></span>sss_key_store_generate_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_store_generate_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyBitLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates key[] in the destination key store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStore</td><td>Key store context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyObject</td><td>Reference to a key and it's properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBitLen</td><td>Crypto algorithm key bit length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Pointer to implementation specific options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga9ca415b9e03331912935045923310d4f" name="ga9ca415b9e03331912935045923310d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ca415b9e03331912935045923310d4f">&#9670;&#160;</a></span>sss_key_store_get_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_store_get_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pKeyBitLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports plain key[] from key store. As Secure Authenticator doesn't support reading key value, this function returned the ECC public key value stored in keyObject. These public key comes from generating ECC keypair or ECDH with ephemeral key operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStore</td><td>Key store context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyObject</td><td>Reference to a key and it's properties </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Plain key buffer. key is copied to this buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dataLen</td><td>Buffer length. Length is overwritten with actual data length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pKeyBitLen</td><td>Key bitlength in case of EC keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga7414a21953a854954c89e547ce21761c" name="ga7414a21953a854954c89e547ce21761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7414a21953a854954c89e547ce21761c">&#9670;&#160;</a></span>sss_key_store_erase_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_store_erase_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete / destroy allocated keyObect . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStore</td><td>The key store </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keyObject</td><td>The key object to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga03ce557c06d6cd014ad63ba1c28b9b8d" name="ga03ce557c06d6cd014ad63ba1c28b9b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03ce557c06d6cd014ad63ba1c28b9b8d">&#9670;&#160;</a></span>sss_key_store_context_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sss_key_store_context_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the key store context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keyStore</td><td>The key store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26cf2aea4e78dc0b3e2469eae1d133b2" name="ga26cf2aea4e78dc0b3e2469eae1d133b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26cf2aea4e78dc0b3e2469eae1d133b2">&#9670;&#160;</a></span>sss_key_object_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_object_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsss__key__store__t.html">sss_key_store_t</a> *&#160;</td>
          <td class="paramname"><em>keyStore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a key object data structure The function initializes keyObject data structure and associates it with a key store in which the plain key and other attributes are stored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keyObject</td><td>The key object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStore</td><td>The key store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70abbddf43382dda6bce2ae5fd96fcfc97c">kStatus_SSS_Success</a></td><td>The operation has completed successfully. </td></tr>
    <tr><td class="paramname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70a32741fa0bf21fca96d56375fc8f826e2">kStatus_SSS_Fail</a></td><td>The operation has failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70aa1c9ed2c7a55af9b3a7c22927973e7d5">kStatus_SSS_InvalidArgument</a></td><td>One of the arguments is invalid for the function to execute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga4e429a389d60abe4b8cac4e244faecbb" name="ga4e429a389d60abe4b8cac4e244faecbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e429a389d60abe4b8cac4e244faecbb">&#9670;&#160;</a></span>sss_key_object_allocate_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_object_allocate_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>keyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsl__sss__api_8h.html#a65bccd97bad72428686bf6aa6ea6f691">sss_key_part_t</a>&#160;</td>
          <td class="paramname"><em>keyPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsl__sss__api_8h.html#ae0d9e4fbd1bf4116b5797c4360818c78">sss_cipher_type_t</a>&#160;</td>
          <td class="paramname"><em>cipherType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyByteLenMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate / pre-provision memory for new key. </p>
<pre class="fragment">           This API allows underlying cryptographic subsystems to perform
           preconditions of before creating any cryptographic key object.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keyObject</td><td>The object If required, update implementation defined values inside the keyObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyId</td><td>Key ID. For symmetric keys in nx se - key id should be in the range of 0x10 to 0x17. For asymmetric CA root keys in nx se - key id should be in the range of 0x00 to 0x04. For asymmetric key pair in nx se - key id should be in the range of 0x00 to 0x04. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPart</td><td>See <a class="el" href="fsl__sss__api_8h.html#a65bccd97bad72428686bf6aa6ea6f691">sss_key_part_t</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cipherType</td><td>See <a class="el" href="fsl__sss__api_8h.html#ae0d9e4fbd1bf4116b5797c4360818c78">sss_cipher_type_t</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyByteLenMax</td><td>Maximum storage this type of key may need. For systems that have their own internal allocation table this would help </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>0 = Persistant Key (Default) or Transient Key. See sss_key_object_mode_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of object allocation. </dd></dl>

</div>
</div>
<a id="gaa7d254bc9f3ee97321070240ef8261fc" name="gaa7d254bc9f3ee97321070240ef8261fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d254bc9f3ee97321070240ef8261fc">&#9670;&#160;</a></span>sss_key_object_get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fsl__sss__api_8h.html#a82a023f4d1bf8b22df395d3bffb0ce70">sss_status_t</a> sss_key_object_get_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsl__sss__api_8h.html#ae0d9e4fbd1bf4116b5797c4360818c78">sss_cipher_type_t</a>&#160;</td>
          <td class="paramname"><em>cipherType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>keyId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get handle to an existing allocated/provisioned/created Object. </p>
<pre class="fragment">        See @ref sss_key_object_allocate_handle.

        After calling this API, Ideally keyObject should become equivalent
        to as set after the calling of @ref
        sss_key_object_allocate_handle api.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keyObject</td><td>The key object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cipherType</td><td>The cipher type of the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyId</td><td>The key identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sss status. </dd></dl>

</div>
</div>
<a id="ga59e10bf4b2a4a0d549ab67ab453991cc" name="ga59e10bf4b2a4a0d549ab67ab453991cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e10bf4b2a4a0d549ab67ab453991cc">&#9670;&#160;</a></span>sss_key_object_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sss_key_object_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsss__object__t.html">sss_object_t</a> *&#160;</td>
          <td class="paramname"><em>keyObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the key object. The function frees key object context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyObject</td><td>Pointer to key object context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
